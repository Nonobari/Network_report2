<!-- 
This file is part of PyFlaSQL.
Original author: Raphael Viera (raphael.viera@emse.fr)
License: check the LICENSE file.
-->
{% extends "base.html" %}
{% block title %}SRIE > SQL Injection > Countermeasure {% endblock %}
{% block content %}
<div class="container p-5 my-5">
    <h2 class="text-center">SRIE > SQL Injection > Countermeasure</h2>

   <!-- Command Execution section -->
   <div class="container p-5 my-5 border bg-light">
       <form method="post" action="">
           {{ content.csrf_token }}
           <div class="form-group mt-2">
            <label for="{{ content.username.id }}">{{ content.username.label.text }}</label>
            {{ content.username(class="form-control") }}
        </div>
        <div class="form-group mt-2">
            <label for="{{ content.password.id }}">{{ content.password.label.text }}</label>
            {{ content.password(class="form-control") }}
        </div>
           <button type="submit" class="btn btn-primary mt-2">Submit</button>
       </form> 
   </div>    
   <div class="container p-5 my-5 border bg-light">
    <p class="lead">
       Pour éviter les injections SQL, le plus important est d'abord, d'utiliser les outils sécurisés que les langages de programmation ont 
       développé pour traiter automatiquement les entrées pour éviter de telles vulnérabilités.<br><br>

       Dans le cas de la bibliothèque SQL alchemy, il faut utiliser l'outil <code>.query.filter_by()</code><br><br>

         <code>user = User.query.filter_by(username=username).first()</code><br><br>
         
         Ensuite, si une réponse est faite (l'utilisateur existe), on peut tester le mot de passe: <br>

            <code>if user and user.password == content.password.data:<br>
                &nbsp;&nbsp;&nbsp;login_user(user)<br>
                &nbsp;&nbsp;&nbsp;return redirect(url_for('loginPage'))</code><br><br>
            </code><br><br>
    </p>
</div>
</div>
{% endblock %}




